<!DOCTYPE html>
<html>
<head>
<title>Crazy Bouncy Balls</title>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

<style>
html, body {
    height: 100%;
    width: 100%;
    overflow: hidden;
}
body {
    margin: 0;
    font-family: Arial, sans-serif;
    background-color: #f0f0f0;
    transition: background-color 0.3s ease;
}
body.editor-active .ball {
    cursor: cell;
}
#world {
    position: absolute;
    width: 100%;
    height: 100%;
    overflow: hidden;
}
.ball {
    margin: 0px;
    position: absolute;
    cursor: pointer;
    z-index: 10;
    border-radius: 50%;
    transition: transform 0.03s ease-out;
    will-change: transform, top, left;
}
/* Ghost balls for seamless wrapping */
.ball.ghost {
    z-index: 9;
    opacity: 1;
    pointer-events: auto; /* Allow clicking ghosts */
}

.ball-inner {
    width: 100%;
    height: 100%;
    border-radius: 50%;
    border: solid 5px black;
    box-sizing: border-box;
    transition: border-color 0.3s ease, filter 0.3s ease, box-shadow 0.1s ease-out;
}
/* Normal Mode Vibrancy */
body:not(.dark-mode):not(.glow-mode) .ball-inner { filter: brightness(1.1); }
body.dark-mode:not(.glow-mode) .ball-inner { filter: brightness(0.7) brightness(1.1); }
body.glow-mode .ball-inner { filter: none; }
body.glow-mode .is-lemon .ball-inner { filter: brightness(0.7); }

/* --- 3D Texture --- */
.ball.is-3d::before {
    content: '';
    position: absolute;
    top: 0; left: 0; right: 0; bottom: 0;
    border-radius: 50%;
    background: radial-gradient(circle at 30% 30%, rgba(255,255,255,0.7) 0%, rgba(255,255,255,0) 15%, transparent 40%, rgba(0,0,0,0.5) 100%);
    z-index: 1;
    transition: background 0.3s ease;
}
.trail.is-3d::before {
    content: ''; position: absolute; top: 0; left: 0; right: 0; bottom: 0; border-radius: 50%;
    background: radial-gradient(circle at 30% 30%, rgba(255,255,255,0.7) 0%, rgba(255,255,255,0) 15%, transparent 40%, rgba(0,0,0,0.5) 100%);
}

/* --- FPS Counter --- */
#fps-counter {
    position: fixed;
    top: 60px;
    left: 10px;
    color: #00FF00;
    font-family: monospace;
    font-size: 12px;
    background: rgba(0,0,0,0.7);
    padding: 4px 8px;
    border-radius: 4px;
    pointer-events: none;
    display: none;
    z-index: 90;
    border: 1px solid #00FF00;
}
#fps-counter.visible { display: block; }

/* --- Menu & Overlay Styles --- */
.menu-box {
    position: fixed;
    top: 10px;
    right: 10px;
    width: auto;
    min-width: 260px;
    padding: 15px;
    border-radius: 10px;
    background-color: rgba(0, 0, 0, 0.65);
    color: #ffffff;
    user-select: none;
    font-size: 16px;
    transition: opacity 0.3s ease, transform 0.3s ease;
    transform: translateX(0);
    opacity: 1;
    z-index: 100;
    box-sizing: border-box;
    display: flex;
    flex-direction: column;
    max-height: calc(var(--vh, 1vh) * 100 - 20px);
}
.menu-header {
    display: flex;
    justify-content: flex-start;
    margin-bottom: 10px;
    flex-wrap: wrap;
    gap: 5px;
}
.menu-box.hidden {
    opacity: 0;
    transform: translateX(110%);
    pointer-events: none;
}
.button-hidden { display: none; }
#editor-content-wrapper {
    overflow-y: auto;
    padding-right: 5px;
    flex-grow: 1;
}
.editor-box-inner-content {
    display: flex;
    flex-direction: column;
    flex-grow: 1;
    min-height: 0;
}
.input-container { margin-bottom: 10px; font-size: 14px; }
.input-container span { font-weight: bold; }
.slider-row { display: flex; align-items: center; margin-top: 5px; }
.slider-row input[type="range"] { flex-grow: 1; margin: 0 5px; }
.slider-row input[type="number"] { width: 60px; text-align: right; }
.slider-row .zero-btn, .slider-row .reset-btn { margin-left: 5px; padding: 4px 6px; font-size: 12px; min-width: 25px; }
.slider-row .reset-btn { background-color: #607D8B; }
.slider-row .reset-btn:hover { background-color: #546E7A; }
button { width: 100%; padding: 10px; margin-top: 10px; border: none; border-radius: 5px; background-color: #4CAF50; color: white; cursor: pointer; font-size: 16px; }
button:hover { background-color: #45a049; }
#clear-btn, .danger-btn { background-color: #f44336; }
#clear-btn:hover, .danger-btn:hover { background-color: #da190b; }
#editor-btn, #reset-btn { background-color: #2196F3; }
#editor-btn:hover, #reset-btn:hover { background-color: #0b7dda; }
#undo-btn { background-color: #ff9800; }
#undo-btn:hover { background-color: #f57c00; }
.warning-btn { background-color: #FFEB3B; color: black; font-weight: bold; }
.warning-btn:hover { background-color: #FBC02D; }

/* --- Menu Header Buttons --- */
.menu-header button {
    width: 36px;
    height: 36px;
    padding: 6px;
    margin: 0;
    background-color: rgba(255, 255, 255, 0.1);
    border: 1px solid rgba(255, 255, 255, 0.3);
    border-radius: 50%;
    transition: all 0.3s ease;
    display: flex;
    align-items: center;
    justify-content: center;
}
.menu-header button:hover { background-color: rgba(255, 255, 255, 0.3); }
.menu-header button.disabled { opacity: 0.4; cursor: not-allowed; }
.menu-header button svg { width: 100%; height: 100%; color: white; }

.menu-header button.active {
    background: radial-gradient(circle, #4dabf5, #2196F3);
    box-shadow: 0 0 8px rgba(33, 150, 243, 0.7);
    border-color: #4dabf5;
}
.menu-header button.glow-active {
    background: radial-gradient(circle, #81c784, #00FF00);
    box-shadow: 0 0 8px rgba(0, 255, 0, 0.7);
    border-color: #81c784;
}
.gyro-controls-disabled { opacity: 0.4; pointer-events: none; }

/* --- Dark & Glow Mode Styles --- */
body.dark-mode { background-color: #1a1a1a; }
body.dark-mode .ball-inner { border-color: #f0f0f0; }

/* --- Editor Specific Styles --- */
#done-btn { position: absolute; top: 10px; left: 10px; width: auto; padding: 5px 10px; font-size: 14px; margin: 0; }
.editor-tabs { display: flex; margin-bottom: 15px; flex-shrink: 0; }
.tab-btn { flex: 1; padding: 8px; background-color: rgba(255, 255, 255, 0.1); border: 1px solid rgba(255, 255, 255, 0.3); color: white; cursor: pointer; text-align: center; font-size: 14px; }
.tab-btn:first-child { border-radius: 5px 0 0 5px; }
.tab-btn:last-child { border-radius: 0 5px 5px 0; }
.tab-btn.active { background-color: #2196F3; }
.tab-content { display: none; }
.tab-content.active { display: block; }
.color-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(30px, 1fr)); gap: 8px; margin-bottom: 15px; }
.color-swatch { width: 30px; height: 30px; border-radius: 50%; cursor: pointer; border: 2px solid white; justify-self: center; }
.lemon-disabled { opacity: 0.4; pointer-events: none; }
input[type="text"].hex-input { width: calc(100% - 10px); padding: 5px; margin-top: 5px; border-radius: 3px; border: none; background-color: rgba(255, 255, 255, 0.8); color: black; }
.editor-info-text { text-align: center; opacity: 0.7; font-style: italic; margin-bottom: 15px; }
.editor-controls.disabled { opacity: 0.4; pointer-events: none; }
.divider { border-top: 1px solid rgba(255, 255, 255, 0.3); margin: 15px 0; }
#editor-content-wrapper::-webkit-scrollbar { width: 8px; }
#editor-content-wrapper::-webkit-scrollbar-track { background: rgba(0,0,0,0.1); }
#editor-content-wrapper::-webkit-scrollbar-thumb { background-color: rgba(255,255,255,0.4); border-radius: 10px; }
#editor-content-wrapper { scrollbar-width: thin; scrollbar-color: rgba(255,255,255,0.4) rgba(0,0,0,0.1); }

/* --- Sound Menu --- */
.sounds-menu { margin-top: 15px; }
.sounds-toggle { width: 100%; background-color: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.3); color: white; padding: 10px; text-align: left; cursor: pointer; font-size: 16px; border-radius: 5px; position: relative; }
.sounds-toggle::after { content: 'â–¼'; position: absolute; right: 15px; transition: transform 0.3s ease; }
.sounds-menu.open .sounds-toggle::after { transform: rotate(180deg); }
.sounds-content { max-height: 0; overflow: hidden; transition: max-height 0.3s ease-out; background-color: rgba(0,0,0,0.2); border-radius: 0 0 5px 5px; padding: 0 10px; }
.sounds-menu.open .sounds-content { max-height: 100px; padding: 10px 10px; }

/* --- Misc Styles --- */
.trail, .particle, .flash { position: absolute; pointer-events: none; }
.trail { border-radius: 50%; opacity: 0.7; transition-property: transform, opacity; }
.particle { border-radius: 50%; z-index: 20; will-change: transform, top, left; }
.flash { z-index: 50; border-radius: 50%; background-color: white; opacity: 0; }
#show-menu-hint { position: fixed; top: 10px; right: 10px; background-color: rgba(0, 0, 0, 0.5); color: #ffffff; padding: 5px 15px; border-radius: 20px; font-size: 14px; opacity: 0; transition: opacity 0.3s ease; pointer-events: none; z-index: 99; }
#show-menu-hint.visible { opacity: 0.2; }
.highlight-box { position: absolute; border: 3px dashed #00FFFF; z-index: 50; pointer-events: none; box-sizing: border-box; border-radius: 50%; }
</style>
</head>
<body>

<div id="world"></div>
<div id="fps-counter">FPS: 60</div>
<div id="show-menu-hint"></div>

<div id="side-box" class="menu-box">
    <div class="menu-header">
        <button id="fullscreen-btn" title="Toggle Fullscreen">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3"></path></svg>
        </button>
        <button id="gyro-btn" class="disabled" title="">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <rect x="3" y="5" width="18" height="14" rx="2"></rect>
                <line x1="8" y1="12" x2="16" y2="12"></line>
                <circle cx="7" cy="12" r="2"></circle>
            </svg>
        </button>
        <button id="pause-btn" title="Pause Simulation">
            <svg id="pause-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <rect x="6" y="4" width="4" height="16"></rect>
                <rect x="14" y="4" width="4" height="16"></rect>
            </svg>
            <svg id="play-icon" style="display:none;" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <polygon points="5 3 19 12 5 21 5 3"></polygon>
            </svg>
        </button>
        <button id="no-walls-btn" title="Toggle Portal Walls">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" stroke-dasharray="2 2">
                <rect x="3" y="3" width="18" height="18" rx="2"></rect>
            </svg>
        </button>
        <button id="dark-mode-btn" title="Cycle Theme">
             <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M12 21.5A9.5 9.5 0 1 0 12 2.5 9.5 9.5 0 0 0 12 21.5z"></path>
                <path d="M12 2.5A9.5 9.5 0 0 1 12 21.5" fill="currentColor"></path>
            </svg>
        </button>
         <button id="fps-btn" title="Toggle FPS Counter">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M4 12h16M4 12l6-6m-6 6 6 6" stroke="none" />
                <text x="50%" y="55%" dominant-baseline="middle" text-anchor="middle" fill="currentColor" stroke="none" font-size="9" font-weight="bold">FPS</text>
                <circle cx="12" cy="12" r="10" stroke-width="1.5" stroke-dasharray="15 40" transform="rotate(135 12 12)"/>
            </svg>
        </button>
    </div>
    <button id="add-btn">Add Ball</button>
   <p style="font-size: 10px; opacity: 0.5; margin: 2px 0 0px; text-align: center;">(Shortcut: A)</p>

    <button id="editor-btn">Ball Editor</button>
    <button id="clear-btn">Clear</button>
<div id="sounds-menu" class="sounds-menu">
<button class="sounds-toggle">Sounds</button>
<div class="sounds-content">
<div class="input-container"><label><input type="checkbox" id="sound-toggle" checked> All Sounds</label></div>
<div class="input-container"><label><input type="checkbox" id="lemon-sound-toggle" checked> Use Lemon Sounds</label></div>
</div>
</div>
<p id="menu-toggle-hint" style="font-size: 12px; opacity: 0.7; margin-top: 15px; text-align: center;"></p>
</div>

<div id="editor-box" class="menu-box hidden">
<button id="done-btn" class="danger-btn">Done</button>
<div style="padding-top: 30px;" class="editor-box-inner-content">
<div class="editor-tabs">
<div class="tab-btn active" id="global-settings-tab">Global Settings</div>
<div class="tab-btn" id="edit-single-tab">Edit Single Ball</div>
</div>
<div id="editor-content-wrapper">
<div id="global-settings-editor" class="tab-content active">
<div class="input-container"> Size: <span id="tamanho-num"></span> <div class="slider-row"><button class="reset-btn">R</button><input id="tamanho" type="range" min="10" max="200" step="1"><input id="tamanho-input" type="number" min="10" max="200" step="1"></div> </div>
<div class="input-container"> Wind: <span id="vento-num"></span> <div class="slider-row" id="vento-slider-row"><button class="reset-btn">R</button><input id="vento" type="range" min="-10" max="10" step="0.01"><input id="vento-input" type="number" min="-10" max="10" step="0.01"></div> </div>
<div class="input-container"> Gravity: <span id="gravidade-num"></span> <div class="slider-row" id="gravidade-slider-row"><button class="reset-btn">R</button><input id="gravidade" type="range" min="-10" max="10" step="0.01"><input id="gravidade-input" type="number" min="-10" max="10" step="0.01"><button class="zero-btn">0</button></div> </div>
<div class="input-container"> Wall Elasticity: <span id="elasticidade-num"></span> <div class="slider-row"><button class="reset-btn">R</button><input id="elasticidade" type="range" min="0" max="1" step="0.01"><input id="elasticidade-input" type="number" min="0" max="1" step="0.01"><button class="zero-btn">0</button></div> </div>
<div class="input-container"> Collision Bounciness: <span id="restitution-num"></span> <div class="slider-row"><button class="reset-btn">R</button><input id="restitution" type="range" min="0" max="1" step="0.01"><input id="restitution-input" type="number" min="0" max="1" step="0.01"><button class="zero-btn">0</button></div> </div>
<div class="divider"></div>
<div class="color-grid" id="color-grid-global"></div>
<div class="input-container"> Custom Color (All): <input type="text" class="hex-input" id="hex-input-global" placeholder="#RRGGBB"> </div>
<button id="randomize-colors-btn">Randomize Colors</button>
<div class="divider"></div>
<div class="input-container"> <label><input type="checkbox" id="ultra-graphics-toggle"> All 3D Mode</label> </div>
<div class="input-container"> <label><input type="checkbox" id="rainbows-toggle"> All Rainbows</label> </div>
<div class="input-container"> <label><input type="checkbox" id="trails-toggle"> All Trails</label> </div>
<div class="input-container"> <label><input type="checkbox" id="color-toggle"> All Color on bounce</label> </div>
<div class="input-container"> <label><input type="checkbox" id="animation-toggle" checked> All Animations</label> </div>
<div class="input-container"> <label><input type="checkbox" id="squishy-toggle"> Extra Squishy</label> </div>
<button id="reset-btn">Reset All Settings</button>
<button id="lemons-btn-global" class="warning-btn">COMBUSTIBLE LEMONS</button>
</div>
<div id="single-ball-editor" class="tab-content">
<div id="editor-info" class="editor-info-text">Select a ball to edit.</div>
<div id="selected-controls" class="editor-controls disabled">
<div class="input-container"> Size: <span id="tamanho-num-s"></span> <div class="slider-row"><button class="reset-btn">R</button><input id="tamanho-s" type="range" min="10" max="200" step="1"><input id="tamanho-input-s" type="number" min="10" max="200" step="1"></div> </div>
<div class="input-container"> Wind: <span id="vento-num-s"></span> <div class="slider-row"><button class="reset-btn">R</button><input id="vento-s" type="range" min="-10" max="10" step="0.01"><input id="vento-input-s" type="number" min="-10" max="10" step="0.01"></div> </div>
<div id="lemon-disabled-controls">
<div class="input-container"> Gravity: <span id="gravidade-num-s"></span> <div class="slider-row"><button class="reset-btn">R</button><input id="gravidade-s" type="range" min="-10" max="10" step="0.01"><input id="gravidade-input-s" type="number" min="-10" max="10" step="0.01"><button class="zero-btn">0</button></div> </div>
<div class="input-container"> Wall Elasticity: <span id="elasticidade-num-s"></span> <div class="slider-row"><button class="reset-btn">R</button><input id="elasticidade-s" type="range" min="0" max="1" step="0.01"><input id="elasticidade-input-s" type="number" min="0" max="1" step="0.01"><button class="zero-btn">0</button></div> </div>
<div class="input-container"> Collision Bounciness: <span id="restitution-num-s"></span> <div class="slider-row"><button class="reset-btn">R</button><input id="restitution-s" type="range" min="0" max="1" step="0.01"><input id="restitution-input-s" type="number" min="0" max="1" step="0.01"><button class="zero-btn">0</button></div> </div>
<div class="divider"></div>
<div class="color-grid" id="color-grid-selected"></div>
<div class="input-container"> Custom Color: <input type="text" class="hex-input" id="hex-input-selected" placeholder="#RRGGBB"> </div>
<button id="randomize-color-btn-single">Random Color</button>
<div class="divider"></div>
<div class="input-container"> <label><input type="checkbox" id="ball-ultra-graphics-toggle"> 3D Mode</label> </div>
<div class="input-container"> <label><input type="checkbox" id="rainbow-toggle"> Rainbow Mode</label> </div>
<div class="input-container"> <label><input type="checkbox" id="ball-color-bounce-toggle"> Change Color on Bounce</label> </div>
<div class="input-container"> <label><input type="checkbox" id="ball-animation-toggle"> Animations</label> </div>
<div class="input-container"> <label><input type="checkbox" id="ball-trail-toggle"> Trails</label> </div>
</div>
<button id="delete-btn" class="danger-btn">Delete Ball</button>
<button id="lemon-btn-single" class="warning-btn">COMBUSTIBLE LEMON</button>
</div>
<button id="undo-btn" class="button-hidden">Undo Delete</button>
</div>
</div>
</div>
</div>

<script type="text/javascript">
// --- GLOBAL STATE & SETTINGS ---
let settings = { gravidade: 2, vento: 0, tamanho: 100, elasticidade: 0.9, restitution: 0.9 };
const defaultSettings = { ...settings };
let bolas = [];
let particles = [];
let deletedBolasStack = [];
let draggedBall = null;
let trailsEnabled = false;
let changeColorOnBounce = false;
let animationsEnabled = true;
let extraSquishy = false;
let allRainbows = false;
let ultraGraphicsEnabled = false;
let selectedBall = null;
let activeEditorTab = 'global-settings';
let lastActiveMenuId = 'side-box';

// --- NEW STATE VARIABLES ---
let isPaused = false;
let isNoWallsActive = false;
let preNoWallsGravity = 0;
let preNoWallsWind = 0;
let darkModeState = 0; // 0: Light, 1: Dark, 2: Glow

// FPS Variables
let showFPS = false;
let lastFrameTime = performance.now();
let frameCount = 0;
let lastFpsUpdate = 0;
const fpsDisplay = document.getElementById('fps-counter');

let soundEnabled = true;
let useLemonSounds = true;
let bounceSoundReady = false;
let explodeSoundReady = false;
let lemonBounceSoundReady = false;
const BOUNCE_CHANNEL_COUNT = 8;
const bounceChannels = [];
const lemonBounceChannels = [];
let bounceChannelIndex = 0;
let lemonBounceChannelIndex = 0;
let audioContext = null;
let soundsUnlocked = false;

// Gyroscope state
let gyroActive = false;
let preGyroSettings = {};

const MAX_SQUISH_VELOCITY = 10;
const MAX_SQUISH_RATIO = 1.19;
const DEFAULT_COLORS = ["#FF0000", "#FFA500", "#FFFF00", "#00FF00", "#0000FF", "#4B0082", "#EE82EE"];
const EXTRA_COLORS = ["#FF69B4", "#00BFFF", "#32CD32", "#FF4500", "#9400D3", "#FFD700"];
const PALETTE_COLORS = ["#FFFFFF", "#000000", ...DEFAULT_COLORS, ...EXTRA_COLORS];
const LUMINANCE_THRESHOLD = 0.0214;

const world = document.getElementById("world");

// --- UTILITY FUNCTIONS ---
const random = (min, max) => Math.random() * (max - min) + min;
const getRandomColor = () => DEFAULT_COLORS[Math.floor(Math.random() * DEFAULT_COLORS.length)];

function getLightness(color) {
    let r = 0, g = 0, b = 0;
    const tempEl = document.createElement('div');
    tempEl.style.color = color;
    tempEl.style.display = 'none';
    document.body.appendChild(tempEl);
    const computedColor = window.getComputedStyle(tempEl).color;
    document.body.removeChild(tempEl);
    const parts = computedColor.match(/[\d.]+/g);
    if (parts && parts.length >= 3) { [r, g, b] = parts.map(v => v / 255); } else { return 0; }
    return (Math.max(r, g, b) + Math.min(r, g, b)) / 2;
}

const getBallProperty = (ball, prop) => {
    if (ball.isLemon) {
        if (prop === 'elasticidade') return 0.5;
        if (prop === 'restitution') return 1.0;
        if (prop === 'gravidade') return defaultSettings.gravidade;
    }
    return (ball[prop] !== null && ball[prop] !== undefined) ? ball[prop] : settings[prop];
};
const getBallUltraGraphicsStatus = (ball) => ball.isLemon ? true : (ball.ultraGraphicsEnabled ?? ultraGraphicsEnabled);
const getBallTrailsStatus = (ball) => ball.isLemon ? false : (ball.trailsEnabled ?? trailsEnabled);
const getBallAnimationStatus = (ball) => ball.isLemon ? false : (ball.animationsEnabled ?? animationsEnabled);

function playBounceSound(ball, volume = 1) {
    if (!soundEnabled) return;
    const now = performance.now();
    if (now - ball.lastSoundTime < 75) return;
    ball.lastSoundTime = now;
    if (ball.isLemon && useLemonSounds) {
        if (!lemonBounceSoundReady) return;
        const channel = lemonBounceChannels[lemonBounceChannelIndex];
        channel.volume = Math.max(0, Math.min(1, volume));
        channel.currentTime = 0;
        channel.play().catch(e => {});
        lemonBounceChannelIndex = (lemonBounceChannelIndex + 1) % BOUNCE_CHANNEL_COUNT;
    } else {
        if (!bounceSoundReady) return;
        const channel = bounceChannels[bounceChannelIndex];
        channel.volume = Math.max(0, Math.min(1, volume));
        channel.currentTime = 0;
        channel.play().catch(e => {});
        bounceChannelIndex = (bounceChannelIndex + 1) % BOUNCE_CHANNEL_COUNT;
    }
}

function playExplodeSound() {
    if (!soundEnabled || !explodeSoundReady) return;
    const audio = new Audio('explode.mp3');
    audio.volume = 1.0;
    audio.play();
}

function initAudioContext() {
    if (soundsUnlocked) return;
    soundsUnlocked = true;
    const AudioContext = window.AudioContext || window.webkitAudioContext;
    if (!AudioContext) return;
    audioContext = new AudioContext();
    if (audioContext.state === 'suspended') { audioContext.resume().catch(e => console.error(e)); }
    const buffer = audioContext.createBuffer(1, 1, 22050);
    const source = audioContext.createBufferSource();
    source.buffer = buffer;
    source.connect(audioContext.destination);
    source.start(0);
}

function closeEditor() {
    document.getElementById("side-box").classList.remove('hidden');
    document.getElementById("editor-box").classList.add('hidden');
    document.body.classList.remove('editor-active');
    if (selectedBall && selectedBall.highlightElm) world.removeChild(selectedBall.highlightElm);
    selectedBall = null;
    lastActiveMenuId = 'side-box';
}

function toggleMenu() {
    const sideBox = document.getElementById('side-box');
    const editorBox = document.getElementById('editor-box');
    const showMenuHint = document.getElementById("show-menu-hint");
    const isAnyMenuVisible = !sideBox.classList.contains('hidden') || !editorBox.classList.contains('hidden');
    sideBox.classList.add('hidden');
    editorBox.classList.add('hidden');
    if (isAnyMenuVisible) { showMenuHint.classList.add('visible'); } 
    else { document.getElementById(lastActiveMenuId).classList.remove('hidden'); showMenuHint.classList.remove('visible'); }
}

function updateUndoButtonVisibility() {
    const undoBtn = document.getElementById('undo-btn');
    if (deletedBolasStack.length > 0) {
        undoBtn.classList.remove('button-hidden');
        undoBtn.textContent = `Undo Delete (${deletedBolasStack.length})`;
    } else { undoBtn.classList.add('button-hidden'); }
}

// --- GYROSCOPE FUNCTIONS ---
function handleOrientation(event) {
    if (!gyroActive) return;
    let { beta, gamma } = event;
    if (beta === null || gamma === null) return;
    let newGravidade, newVento;
    const maxForce = 5;
    const orientation = screen.orientation ? screen.orientation.angle : 0;
    switch (orientation) {
        case 90: newVento = (Math.max(-90, Math.min(90, beta)) / 90) * maxForce; newGravidade = -(Math.max(-90, Math.min(90, gamma)) / 90) * maxForce; break;
        case -90: case 270: newVento = -(Math.max(-90, Math.min(90, beta)) / 90) * maxForce; newGravidade = (Math.max(-90, Math.min(90, gamma)) / 90) * maxForce; break;
        case 180: newVento = -(Math.max(-90, Math.min(90, gamma)) / 90) * maxForce; newGravidade = -(Math.max(-90, Math.min(90, beta)) / 90) * maxForce; break;
        case 0: default: newVento = (Math.max(-90, Math.min(90, gamma)) / 90) * maxForce; newGravidade = (Math.max(-90, Math.min(90, beta)) / 90) * maxForce; break;
    }
    settings.vento = newVento;
    settings.gravidade = newGravidade;
    syncUIToSettings();
}

async function toggleGyro() {
    if (typeof DeviceOrientationEvent.requestPermission === 'function') {
        const permission = await DeviceOrientationEvent.requestPermission();
        if (permission !== 'granted') {
            alert('Gyroscope permission was not granted.');
            if (gyroActive) {
                gyroActive = false; 
                const gyroBtn = document.getElementById('gyro-btn');
                gyroBtn.classList.remove('active');
                window.removeEventListener('deviceorientation', handleOrientation, true);
                document.getElementById('gravidade-slider-row').classList.remove('gyro-controls-disabled');
                document.getElementById('vento-slider-row').classList.remove('gyro-controls-disabled');
                settings.gravidade = preGyroSettings.gravidade;
                settings.vento = preGyroSettings.vento;
                syncUIToSettings();
            }
            return;
        }
    }
    gyroActive = !gyroActive;
    const gyroBtn = document.getElementById('gyro-btn');
    const gravidadeSliderRow = document.getElementById('gravidade-slider-row');
    const ventoSliderRow = document.getElementById('vento-slider-row');
    if (gyroActive) {
        gyroBtn.classList.add('active');
        preGyroSettings.gravidade = settings.gravidade;
        preGyroSettings.vento = settings.vento;
        gravidadeSliderRow.classList.add('gyro-controls-disabled');
        ventoSliderRow.classList.add('gyro-controls-disabled');
        window.addEventListener('deviceorientation', handleOrientation, true);
    } else {
        gyroBtn.classList.remove('active');
        window.removeEventListener('deviceorientation', handleOrientation, true);
        gravidadeSliderRow.classList.remove('gyro-controls-disabled');
        ventoSliderRow.classList.remove('gyro-controls-disabled');
        settings.gravidade = preGyroSettings.gravidade;
        settings.vento = preGyroSettings.vento;
        syncUIToSettings();
    }
}


// --- CORE PHYSICS & ANIMATION ---
function squishBall(ball, impactVelocity, angleDeg = 0) {
    const timeout = (extraSquishy ? 50 : 30);
    const squishFactor = Math.min(Math.abs(impactVelocity) / MAX_SQUISH_VELOCITY, 1);
    const stretch = 1 + (MAX_SQUISH_RATIO - 1) * squishFactor;
    const squash = 1 / stretch;
    const isHorizontal = Math.abs(angleDeg) > 45 && Math.abs(angleDeg) < 135;
    const scaleX = isHorizontal ? squash : stretch;
    const scaleY = isHorizontal ? stretch : squash;
    ball.elm.style.transitionDuration = `${(extraSquishy ? 0.05 : 0.03)}s`;
    ball.elm.style.transform = `scaleX(${scaleX}) scaleY(${scaleY})`;
    setTimeout(() => { if (ball.elm) ball.elm.style.transform = 'none'; }, timeout);
}

function createBall() {
    const bolaElm = document.createElement("div");
    bolaElm.className = "ball";
    const innerElm = document.createElement("div");
    innerElm.className = "ball-inner";
    bolaElm.appendChild(innerElm);

    // Create Ghost Elements for Seamless Wrapping
    const ghosts = [];
    for(let i=0; i<3; i++) {
        const gElm = document.createElement("div");
        gElm.className = "ball ghost";
        gElm.style.display = 'none';
        const gInner = document.createElement("div");
        gInner.className = "ball-inner";
        gElm.appendChild(gInner);
        world.appendChild(gElm);
        ghosts.push({ elm: gElm, inner: gInner });
    }

    const newBall = {
        elm: bolaElm, innerElm: innerElm, ghosts: ghosts,
        x: random(settings.tamanho, window.innerWidth - settings.tamanho),
        y: random(settings.tamanho, window.innerHeight - settings.tamanho),
        velocidadeX: random(-10, 10),
        velocidadeY: random(-10, 10),
        isRainbow: allRainbows,
        hue: random(0, 360),
        animationsEnabled: true,
        trailsEnabled: null,
        changeColorOnBounceEnabled: changeColorOnBounce,
        highlightElm: null,
        isLemon: false,
        toBeDeleted: false,
        lastSoundTime: 0,
        tamanho: null, gravidade: null, vento: null, elasticidade: null, restitution: null,
        ultraGraphicsEnabled: null
    };

    const size = getBallProperty(newBall, 'tamanho');
    bolaElm.style.width = `${size}px`;
    bolaElm.style.height = `${size}px`;
    innerElm.style.backgroundColor = getRandomColor();
    world.appendChild(bolaElm);
    bolas.push(newBall);
    
    const mouseHandler = (e) => mouseDown(e, newBall);
    bolaElm.addEventListener("mousedown", mouseHandler);
    bolaElm.addEventListener("touchstart", mouseHandler);
    ghosts.forEach(g => {
        g.elm.addEventListener("mousedown", mouseHandler);
        g.elm.addEventListener("touchstart", mouseHandler);
    });
}

function resolveCollision(ball1, ball2) {
    if (ball1.toBeDeleted || ball2.toBeDeleted) return;

    const b1Size = getBallProperty(ball1, 'tamanho');
    const b2Size = getBallProperty(ball2, 'tamanho');
    const totalRadius = (b1Size + b2Size) / 2;

    const dx = ball2.x - ball1.x;
    const dy = ball2.y - ball1.y;
    let distance = Math.sqrt(dx * dx + dy * dy);
    if (distance === 0) { distance = 0.1; ball1.x += 0.1; }

    if (distance < totalRadius) {
        const nx = dx / distance;
        const ny = dy / distance;
        const dvx = ball1.velocidadeX - ball2.velocidadeX;
        const dvy = ball1.velocidadeY - ball2.velocidadeY;
        const impactSpeed = dvx * nx + dvy * ny;

        if (impactSpeed < -4) {
            playBounceSound(ball1, Math.abs(impactSpeed) / 20);
            playBounceSound(ball2, Math.abs(impactSpeed) / 20);
        }

        if (changeColorOnBounce && impactSpeed < -6) {
            if (ball1.changeColorOnBounceEnabled && !ball1.isRainbow && !ball1.isLemon) ball1.innerElm.style.backgroundColor = getRandomColor();
            if (ball2.changeColorOnBounceEnabled && !ball2.isRainbow && !ball2.isLemon) ball2.innerElm.style.backgroundColor = getRandomColor();
        }

        // Check for explosions - PREVENT DUPLICATES
        if ((ball1.isLemon || ball2.isLemon) && impactSpeed < -40) {
            let explode1 = ball1.isLemon && !ball1.toBeDeleted;
            let explode2 = ball2.isLemon && !ball2.toBeDeleted;
            
            if (explode1) {
                ball1.toBeDeleted = true;
                createExplosion(ball1.x, ball1.y, ball1);
            }
            if (explode2) {
                ball2.toBeDeleted = true;
                createExplosion(ball2.x, ball2.y, ball2);
            }
            // If either exploded, stop physics calculation for this pair immediately
            if (explode1 || explode2) return; 
        }

        const angleDeg = Math.atan2(ny, nx) * (180 / Math.PI) + 90;
        const tx = -ny;
        const ty = nx;
        const dpTan1 = ball1.velocidadeX * tx + ball1.velocidadeY * ty;
        const dpTan2 = ball2.velocidadeX * tx + ball2.velocidadeY * ty;
        const dpNorm1 = ball1.velocidadeX * nx + ball1.velocidadeY * ny;
        const dpNorm2 = ball2.velocidadeX * nx + ball2.velocidadeY * ny;

        if (animationsEnabled && getBallAnimationStatus(ball1) && getBallAnimationStatus(ball2)) {
            squishBall(ball1, dpNorm1, angleDeg);
            squishBall(ball2, dpNorm2, angleDeg);
        }

        const overlap = (totalRadius - distance);
        const mass1 = b1Size * b1Size;
        const mass2 = b2Size * b2Size;
        const totalMass = mass1 + mass2;

        ball1.x -= overlap * (mass2 / totalMass) * nx;
        ball1.y -= overlap * (mass2 / totalMass) * ny;
        ball2.x += overlap * (mass1 / totalMass) * nx;
        ball2.y += overlap * (mass1 / totalMass) * ny;

        const avgRestitution = (getBallProperty(ball1, 'restitution') + getBallProperty(ball2, 'restitution')) / 2;
        const m1 = (dpNorm1 * (mass1 - mass2) + 2 * mass2 * dpNorm2) / totalMass;
        const m2 = (dpNorm2 * (mass2 - mass1) + 2 * mass1 * dpNorm1) / totalMass;
        ball1.velocidadeX = tx * dpTan1 + nx * m1 * avgRestitution;
        ball1.velocidadeY = ty * dpTan1 + ny * m1 * avgRestitution;
        ball2.velocidadeX = tx * dpTan2 + nx * m2 * avgRestitution;
        ball2.velocidadeY = ty * dpTan2 + ny * m2 * avgRestitution;
    }
}

function createExplosion(x, y, explodingBall) {
    playExplodeSound();
    applyExplosionForce(x, y, explodingBall);

    // Save color before deletion for particles
    const ballColor = explodingBall.innerElm.style.backgroundColor;

    const flash = document.createElement('div');
    flash.className = 'flash';
    flash.style.left = `${x - 200}px`;
    flash.style.top = `${window.innerHeight - y - 200}px`;
    flash.style.width = '400px';
    flash.style.height = '400px';
    world.appendChild(flash);
    
    // Fixed: Explicit transition to prevent glitching/sticking
    requestAnimationFrame(() => {
        flash.style.transition = "opacity 0.15s ease-out, transform 0.15s ease-out"; 
        flash.style.opacity = '0.8';
        flash.style.transform = 'scale(1.5)';
        setTimeout(() => { flash.style.opacity = '0'; }, 50);
        setTimeout(() => { if (flash.parentElement) world.removeChild(flash) }, 250);
    });

    // Fixed: Increased particle count and brightness, matched color
    for (let i = 0; i < 60; i++) {
        const particleElm = document.createElement('div');
        particleElm.className = 'particle';
        const size = random(3, 12);
        particleElm.style.width = `${size}px`;
        particleElm.style.height = `${size}px`;
        particleElm.style.backgroundColor = ballColor; // Match ball color
        particleElm.style.boxShadow = `0 0 10px ${ballColor}`; // Add brightness/glow
        const angle = random(0, Math.PI * 2);
        const speed = random(8, 25);
        particles.push({
            elm: particleElm, x: x, y: y,
            vx: Math.cos(angle) * speed,
            vy: Math.sin(angle) * speed,
            lifetime: 60 + Math.random()*20,
        });
        world.appendChild(particleElm);
    }
}

function applyExplosionForce(explosionX, explosionY, explodingBall) {
    const explosionPower = 60;
    const explosionRadius = 400;
    bolas.forEach(otherBall => {
        if (otherBall === explodingBall || otherBall.toBeDeleted) return;
        const dx = otherBall.x - explosionX;
        const dy = otherBall.y - explosionY;
        const distance = Math.sqrt(dx * dx + dy * dy);
        if (distance < explosionRadius && distance > 0) {
            const force = (1 - distance / explosionRadius);
            const nx = dx / distance;
            const ny = dy / distance;
            otherBall.velocidadeX += nx * force * explosionPower;
            otherBall.velocidadeY += ny * force * explosionPower;
        }
    });
}

function runPhysics() {
    // Clean up deleted balls FIRST to avoid processing them
    for (let i = bolas.length - 1; i >= 0; i--) {
        if (bolas[i].toBeDeleted) {
            if(bolas[i].elm.parentNode) world.removeChild(bolas[i].elm);
            bolas[i].ghosts.forEach(g => { if(g.elm.parentNode) world.removeChild(g.elm); });
            bolas.splice(i, 1);
        }
    }

    // Apply forces
    bolas.forEach(l => {
        if (l !== draggedBall) {
            l.velocidadeY -= getBallProperty(l, "gravidade");
            l.velocidadeX += getBallProperty(l, "vento");
            l.velocidadeX *= .99;
            l.velocidadeY *= .99;
            l.x += l.velocidadeX;
            l.y += l.velocidadeY;
        }
    });

    // Sub-steps for stability
    for (let k = 0; k < 3; k++) {
        bolas.forEach(l => {
            if (l.toBeDeleted) return; // Skip deleted
            
            const t = getBallProperty(l, "tamanho") / 2; 
            const e = getBallProperty(l, "elasticidade");
            let o = 0;
            let explode = false;
            const useAnimations = getBallAnimationStatus(l);

            if (isNoWallsActive) {
                // Seamless Wrapping Logic (Physics side)
                // We just wrap coordinates. Visuals handle the ghost appearance.
                const w = window.innerWidth;
                const h = window.innerHeight;
                if (l.x > w) l.x -= w;
                else if (l.x < 0) l.x += w;
                if (l.y > h) l.y -= h;
                else if (l.y < 0) l.y += h;
            } else {
                // Standard Bouncing
                if (l.x + t > window.innerWidth) { o = l.velocidadeX; l.x = window.innerWidth - t; if (l.isLemon && Math.abs(o) > 40) explode = true; else { animationsEnabled && useAnimations && squishBall(l, o, 90); l.velocidadeX *= -e; if (Math.abs(o) > 4) playBounceSound(l, Math.abs(o) / 20); } }
                else if (l.x - t < 0) { o = l.velocidadeX; l.x = t; if (l.isLemon && Math.abs(o) > 40) explode = true; else { animationsEnabled && useAnimations && squishBall(l, o, 90); l.velocidadeX *= -e; if (Math.abs(o) > 4) playBounceSound(l, Math.abs(o) / 20); } }

                if (l.y + t > window.innerHeight) { o = l.velocidadeY; l.y = window.innerHeight - t; if (l.isLemon && Math.abs(o) > 40) explode = true; else { animationsEnabled && useAnimations && squishBall(l, o, 0); l.velocidadeY *= -e; if (Math.abs(o) > 4) playBounceSound(l, Math.abs(o) / 20); } }
                else if (l.y - t < 0) { o = l.velocidadeY; l.y = t; if (l.isLemon && Math.abs(o) > 40) explode = true; else { animationsEnabled && useAnimations && squishBall(l, o, 0), l.velocidadeY *= -e; if (Math.abs(o) > 4) playBounceSound(l, Math.abs(o) / 20); } }
            }

            if (explode && !l.toBeDeleted) {
                l.toBeDeleted = true;
                createExplosion(l.x, l.y, l);
            }

            if (changeColorOnBounce && l.changeColorOnBounceEnabled && !l.isRainbow && !l.isLemon && Math.abs(o) > 6) {
                l.innerElm.style.backgroundColor = getRandomColor();
            }
        });

        for (let i = 0; i < bolas.length; i++) {
            for (let j = i + 1; j < bolas.length; j++) {
                if (!bolas[i].toBeDeleted && !bolas[j].toBeDeleted) {
                    resolveCollision(bolas[i], bolas[j]);
                }
            }
        }
    }
}

function updateParticles() {
    for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        p.vy -= settings.gravidade * 0.5;
        p.x += p.vx;
        p.y += p.vy;
        p.lifetime -= 2; // Faster decay to save FPS
        p.elm.style.opacity = p.lifetime / 80;
        p.elm.style.left = `${p.x}px`;
        p.elm.style.top = `${window.innerHeight - p.y}px`;
        if (p.lifetime <= 0) {
            world.removeChild(p.elm);
            particles.splice(i, 1);
        }
    }
}

function renderVisuals() {
    // FPS Update
    if (showFPS) {
        const now = performance.now();
        frameCount++;
        if (now - lastFpsUpdate >= 500) {
            const fps = Math.round((frameCount * 1000) / (now - lastFpsUpdate));
            fpsDisplay.textContent = `FPS: ${fps}`;
            lastFpsUpdate = now;
            frameCount = 0;
        }
    }

    const isGlowMode = darkModeState === 2;
    const screenWidth = window.innerWidth;
    const screenHeight = window.innerHeight;

    bolas.forEach(l => {
        if (l.isLemon) l.elm.classList.add("is-lemon");
        else l.elm.classList.remove("is-lemon");

        const t = getBallProperty(l, "tamanho");
        const halfT = t / 2;
        const is3d = getBallUltraGraphicsStatus(l);

        // Visuals Logic (Glow, Shadows, Rainbows) - Optimized
        if (l.isRainbow && !l.isLemon) {
            l.hue = (l.hue + 1) % 360;
            l.innerElm.style.backgroundColor = `hsl(${l.hue}, 100%, 50%)`;
        }
        
        let dynamicShadows = [];
        if (isGlowMode && !l.isLemon) {
             const lightness = getLightness(l.innerElm.style.backgroundColor);
             if(lightness > LUMINANCE_THRESHOLD) {
                const rgbValues = l.innerElm.style.backgroundColor.match(/\d+/g);
                if (rgbValues) {
                     const br = 40; const or = 100;
                     dynamicShadows.push(`inset 0 0 20px rgba(255,255,255,0.5)`, `0 0 ${br}px ${br/3}px rgba(${rgbValues[0]},${rgbValues[1]},${rgbValues[2]},0.9)`, `0 0 ${or}px ${or/3}px rgba(${rgbValues[0]},${rgbValues[1]},${rgbValues[2]},0.35)`);
                }
             }
        }
        if (is3d) {
            l.elm.classList.add("is-3d");
            l.innerElm.style.border = "none";
            const heightRatio = Math.max(0, l.y / 1.2 / window.innerHeight);
            const shadowOpacity = isGlowMode ? 0 : (darkModeState > 0 ? 0.5 : Math.max(0,.6-.5*heightRatio));
            if (shadowOpacity > 0) dynamicShadows.push(`0px ${5+80*heightRatio}px ${5+30*heightRatio}px ${2+10*heightRatio}px rgba(0,0,0,${shadowOpacity})`);
        } else {
             l.elm.classList.remove("is-3d");
             // Fixed: Do not force border in Glow Mode to avoid the "highlight box" frame effect
             if (isGlowMode && !l.isLemon) {
                 l.innerElm.style.border = "none";
             } else {
                 l.innerElm.style.border = "solid 5px";
             }
        }
        l.elm.style.boxShadow = dynamicShadows.join(', ');

        // Main Ball Position
        l.elm.style.width = `${t}px`; l.elm.style.height = `${t}px`; 
        l.elm.style.top = `${window.innerHeight-l.y-halfT}px`; l.elm.style.left = `${l.x-halfT}px`;
        if (l.highlightElm) { l.highlightElm.style.top = `${window.innerHeight-l.y-halfT-3}px`; l.highlightElm.style.left = `${l.x-halfT-3}px`; l.highlightElm.style.width = `${t}px`; l.highlightElm.style.height = `${t}px`; }

        // --- Seamless Walls Ghost Rendering ---
        if (isNoWallsActive) {
            const offsets = [];
            // Horizontal Wraps
            if (l.x + halfT > screenWidth) offsets.push({x: -screenWidth, y: 0}); 
            else if (l.x - halfT < 0) offsets.push({x: screenWidth, y: 0});     
            // Vertical Wraps
            if (l.y + halfT > screenHeight) offsets.push({x: 0, y: -screenHeight}); 
            else if (l.y - halfT < 0) offsets.push({x: 0, y: screenHeight});    
            // Diagonal Corner
            if (offsets.length === 2) offsets.push({x: offsets[0].x + offsets[1].x, y: offsets[0].y + offsets[1].y});

            l.ghosts.forEach((ghost, index) => {
                if (index < offsets.length) {
                    const off = offsets[index];
                    ghost.elm.style.display = 'block';
                    ghost.elm.style.width = l.elm.style.width;
                    ghost.elm.style.height = l.elm.style.height;
                    // Y axis in physics is bottom-up, CSS is top-down. 
                    // Visual y offset needs to be inverse of physics offset direction
                    const visualOffY = -off.y; 
                    ghost.elm.style.top = `calc(${l.elm.style.top} + ${visualOffY}px)`;
                    ghost.elm.style.left = `calc(${l.elm.style.left} + ${off.x}px)`;

                    ghost.elm.className = l.elm.className + " ghost"; 
                    ghost.inner.style.backgroundColor = l.innerElm.style.backgroundColor;
                    ghost.inner.style.border = l.innerElm.style.border;
                    ghost.inner.style.filter = l.innerElm.style.filter;
                    ghost.elm.style.transform = l.elm.style.transform; 
                    ghost.elm.style.boxShadow = l.elm.style.boxShadow; 
                    if (l.isLemon) ghost.elm.classList.add("is-lemon");
                } else {
                    ghost.elm.style.display = 'none';
                }
            });
        } else {
            l.ghosts.forEach(g => g.elm.style.display = 'none');
        }

        // Trails Logic
        const useTrails = getBallTrailsStatus(l);
        if (useTrails && (Math.abs(l.velocidadeX) > 1 || Math.abs(l.velocidadeY) > 1)) {
            const trailElm = document.createElement("div");
            trailElm.className = "trail";
            if (is3d) trailElm.classList.add("is-3d");
            trailElm.style.backgroundColor = l.innerElm.style.backgroundColor;
            trailElm.style.width = `${t}px`; trailElm.style.height = `${t}px`;
            trailElm.style.left = l.elm.style.left; trailElm.style.top = l.elm.style.top;
            trailElm.style.transitionDuration = `0.5s`;
            world.appendChild(trailElm);
            setTimeout(() => { trailElm.style.transform = "scale(0)"; trailElm.style.opacity = "0"; setTimeout(() => { if (trailElm.parentElement) world.removeChild(trailElm) }, 500); }, 10);
        }
    })
}

function gameLoop() {
    if (!isPaused) {
        runPhysics();
        updateParticles();
    }
    renderVisuals();
    requestAnimationFrame(gameLoop);
}

function updateEditorUI() {
    const infoText = document.getElementById('editor-info');
    const controls = document.getElementById('selected-controls');
    const lemonDisabledControls = document.getElementById('lemon-disabled-controls');
    const deleteBtn = document.getElementById('delete-btn');
    const lemonBtn = document.getElementById('lemon-btn-single');

    if (!selectedBall) {
        infoText.textContent = "Select a ball to edit.";
        controls.classList.add('disabled');
    } else {
        const isLemon = selectedBall.isLemon;
        infoText.textContent = `Editing 1 ${isLemon ? 'lemon' : 'ball'}.`;
        controls.classList.remove('disabled');
        lemonDisabledControls.classList.toggle('lemon-disabled', isLemon);
        lemonBtn.style.display = isLemon ? 'none' : 'block';
        deleteBtn.textContent = isLemon ? 'Delete Lemon' : 'Delete Ball';
        document.getElementById('ball-ultra-graphics-toggle').checked = getBallUltraGraphicsStatus(selectedBall);
        document.getElementById('rainbow-toggle').checked = selectedBall.isRainbow && !isLemon;
        document.getElementById('ball-color-bounce-toggle').checked = selectedBall.changeColorOnBounceEnabled;
        document.getElementById('ball-color-bounce-toggle').disabled = selectedBall.isRainbow || isLemon;
        document.getElementById('ball-animation-toggle').checked = getBallAnimationStatus(selectedBall);
        document.getElementById('ball-trail-toggle').checked = getBallTrailsStatus(selectedBall);
        ['tamanho', 'gravidade', 'vento', 'elasticidade', 'restitution'].forEach(key => {
            const val = getBallProperty(selectedBall, key);
            document.getElementById(`${key}-s`).value = val;
            document.getElementById(`${key}-input-s`).value = val;
            document.getElementById(`${key}-num-s`).textContent = val.toFixed(key === 'tamanho' ? 0 : 2);
        });
    }
}

function applyColorToBall(color, ball) {
    ball.isLemon = false; ball.elm.classList.remove('is-lemon'); ball.isRainbow = false;
    ball.innerElm.style.backgroundColor = color; ball.changeColorOnBounceEnabled = false;
    updateEditorUI();
}

function mouseDown(e, ball) {
    initAudioContext();
    e.preventDefault();
    if (document.body.classList.contains("editor-active") && activeEditorTab === "edit-single") {
        if (selectedBall === ball) {
            if (selectedBall.highlightElm) world.removeChild(selectedBall.highlightElm);
            selectedBall.highlightElm = null; selectedBall = null;
        } else {
            if (selectedBall && selectedBall.highlightElm) { world.removeChild(selectedBall.highlightElm); selectedBall.highlightElm = null; }
            selectedBall = ball;
            const highlight = document.createElement("div"); highlight.className = "highlight-box";
            selectedBall.highlightElm = highlight; world.appendChild(highlight);
        }
        updateEditorUI();
    } else {
        draggedBall = ball;
        draggedBall.lastX = ball.x; draggedBall.lastY = ball.y;
        draggedBall.moved = false;
    }
}

function mouseUp() {
    if(draggedBall){
        if(draggedBall.moved){ draggedBall.velocidadeX = (draggedBall.x - draggedBall.lastX) * 0.5; draggedBall.velocidadeY = (draggedBall.y - draggedBall.lastY) * 0.5; } 
        else { draggedBall.velocidadeX = 0; draggedBall.velocidadeY = 0; }
        draggedBall = null;
    }
}

function mouseMove(e) {
    if(draggedBall){
        draggedBall.lastX = draggedBall.x; draggedBall.lastY = draggedBall.y;
        const t = e.targetTouches ? e.targetTouches[0] : (e.changedTouches ? e.changedTouches[e.changedTouches.length-1] : e);
        draggedBall.x = t.pageX; draggedBall.y = window.innerHeight - t.pageY;
        draggedBall.moved = true;
    }
}

function setupEditor() {
    const colorGridSelected = document.getElementById("color-grid-selected");
    const colorGridGlobal = document.getElementById("color-grid-global");
    [colorGridSelected, colorGridGlobal].forEach(grid => grid.innerHTML = "");
    PALETTE_COLORS.forEach(color => {
        const swatchSelected = document.createElement("div"); swatchSelected.className = "color-swatch"; swatchSelected.style.backgroundColor = color;
        swatchSelected.addEventListener("click", () => { if (selectedBall) applyColorToBall(color, selectedBall); });
        colorGridSelected.appendChild(swatchSelected);
        const swatchGlobal = document.createElement("div"); swatchGlobal.className = "color-swatch"; swatchGlobal.style.backgroundColor = color;
        swatchGlobal.addEventListener("click", () => { bolas.forEach(ball => applyColorToBall(color, ball)); allRainbows = false; changeColorOnBounce = false; document.getElementById("color-toggle").disabled = false; syncUIToSettings(); });
        colorGridGlobal.appendChild(swatchGlobal);
    });
    const hexInputSelected = document.getElementById("hex-input-selected");
    const applySelectedColorFromInput = (value) => { if (selectedBall && /^#([0-9A-F]{3}){1,2}$/i.test(value)) applyColorToBall(value, selectedBall); };
    hexInputSelected.addEventListener("change", (e) => applySelectedColorFromInput(e.target.value));
    const hexInputGlobal = document.getElementById("hex-input-global");
    const applyGlobalColorFromInput = (value) => { if (/^#([0-9A-F]{3}){1,2}$/i.test(value)) { bolas.forEach(ball => applyColorToBall(value, ball)); allRainbows = false; changeColorOnBounce = false; document.getElementById("color-toggle").disabled = false; syncUIToSettings(); } };
    hexInputGlobal.addEventListener("change", (e) => applyGlobalColorFromInput(e.target.value));

    document.getElementById('ball-ultra-graphics-toggle').addEventListener('change', t => { if (selectedBall) selectedBall.ultraGraphicsEnabled = t.target.checked });
    document.getElementById("rainbow-toggle").addEventListener("change", t => { if (selectedBall) { selectedBall.isRainbow = t.target.checked; updateEditorUI(); } });
    document.getElementById("ball-color-bounce-toggle").addEventListener("change", t => { if (selectedBall) selectedBall.changeColorOnBounceEnabled = t.target.checked });
    document.getElementById("ball-animation-toggle").addEventListener("change", t => { if (selectedBall) selectedBall.animationsEnabled = t.target.checked });
    document.getElementById("ball-trail-toggle").addEventListener("change", t => { if (selectedBall) selectedBall.trailsEnabled = t.target.checked });
    document.getElementById("edit-single-tab").addEventListener("click", () => { activeEditorTab = "edit-single"; document.getElementById("edit-single-tab").classList.add("active"); document.getElementById("global-settings-tab").classList.remove("active"); document.getElementById("single-ball-editor").classList.add("active"); document.getElementById("global-settings-editor").classList.remove("active"); lastActiveMenuId = "editor-box"; updateUndoButtonVisibility() });
    document.getElementById("global-settings-tab").addEventListener("click", () => { activeEditorTab = "global-settings"; if (selectedBall && selectedBall.highlightElm) { world.removeChild(selectedBall.highlightElm); selectedBall.highlightElm = null; selectedBall = null; } document.getElementById("edit-single-tab").classList.remove("active"); document.getElementById("global-settings-tab").classList.add("active"); document.getElementById("single-ball-editor").classList.remove("active"); document.getElementById("global-settings-editor").classList.add("active"); lastActiveMenuId = "side-box" });
}

function syncUIToSettings() {
    const e={tamanho:"tamanho-num",gravidade:"gravidade-num",vento:"vento-num",elasticidade:"elasticidade-num",restitution:"restitution-num"};Object.keys(e).forEach(t=>{const l=document.getElementById(t),a=document.getElementById(`${t}-input`),c=document.getElementById(e[t]);l.value=settings[t],a&&(a.value=settings[t]),c.textContent=settings[t].toFixed("tamanho"===t?0:2)}),document.getElementById("ultra-graphics-toggle").checked=ultraGraphicsEnabled,document.getElementById("trails-toggle").checked=trailsEnabled,document.getElementById("color-toggle").checked=changeColorOnBounce,document.getElementById("animation-toggle").checked=animationsEnabled,document.getElementById("squishy-toggle").checked=extraSquishy,document.getElementById("rainbows-toggle").checked=allRainbows
}

function init() {
    const vh = window.innerHeight * 0.01;
    document.documentElement.style.setProperty('--vh', `${vh}px`);
    window.addEventListener('resize', () => {
        const vh = window.innerHeight * 0.01;
        document.documentElement.style.setProperty('--vh', `${vh}px`);
    });

    const audioCheckBounce = new Audio('bounce.mp3');
    audioCheckBounce.oncanplaythrough = () => { bounceSoundReady = true; for (let i = 0; i < BOUNCE_CHANNEL_COUNT; i++) bounceChannels.push(new Audio('bounce.mp3')); };
    audioCheckBounce.onerror = () => { bounceSoundReady = false; };

    const audioCheckLemon = new Audio('lemon_bounce.mp3');
    audioCheckLemon.oncanplaythrough = () => { lemonBounceSoundReady = true; for (let i = 0; i < BOUNCE_CHANNEL_COUNT; i++) lemonBounceChannels.push(new Audio('lemon_bounce.mp3')); };
    audioCheckLemon.onerror = () => { lemonBounceSoundReady = false; };

    const audioCheckExplode = new Audio('explode.mp3');
    audioCheckExplode.oncanplaythrough = () => { explodeSoundReady = true; };
    audioCheckExplode.onerror = () => { explodeSoundReady = false; };

    // --- Fullscreen Button Logic ---
    const fullscreenBtn = document.getElementById('fullscreen-btn');
    function toggleFullscreen() {
        if (!document.fullscreenElement) { document.documentElement.requestFullscreen().catch(err => {}); } 
        else { if (document.exitFullscreen) { document.exitFullscreen(); } }
    }
    function updateFullscreenIcon() { fullscreenBtn.classList.toggle('active', !!document.fullscreenElement); }
    fullscreenBtn.addEventListener('click', toggleFullscreen);
    document.addEventListener('fullscreenchange', updateFullscreenIcon);

    // --- BUTTON LOGIC ---
    const pauseBtn = document.getElementById('pause-btn');
    const pauseIcon = document.getElementById('pause-icon');
    const playIcon = document.getElementById('play-icon');
    pauseBtn.addEventListener('click', () => {
        isPaused = !isPaused;
        if (isPaused) { pauseIcon.style.display = 'none'; playIcon.style.display = 'block'; pauseBtn.title = "Play Simulation"; pauseBtn.classList.add('active'); } 
        else { pauseIcon.style.display = 'block'; playIcon.style.display = 'none'; pauseBtn.title = "Pause Simulation"; pauseBtn.classList.remove('active'); }
    });

    const noWallsBtn = document.getElementById('no-walls-btn');
    noWallsBtn.addEventListener('click', () => {
        isNoWallsActive = !isNoWallsActive;
        noWallsBtn.classList.toggle('active');
        if (isNoWallsActive) {
            preNoWallsGravity = settings.gravidade; preNoWallsWind = settings.vento;
            settings.gravidade = 0; settings.vento = 0;
        } else {
            settings.gravidade = preNoWallsGravity; settings.vento = preNoWallsWind;
        }
        syncUIToSettings();
    });

    const darkModeBtn = document.getElementById('dark-mode-btn');
    darkModeBtn.addEventListener('click', () => {
        darkModeState = (darkModeState + 1) % 3;
        const bodyClassList = document.body.classList;
        bodyClassList.remove('dark-mode', 'glow-mode');
        darkModeBtn.classList.remove('active', 'glow-active');
        if (darkModeState === 1) { bodyClassList.add('dark-mode'); darkModeBtn.classList.add('active'); } 
        else if (darkModeState === 2) { bodyClassList.add('dark-mode', 'glow-mode'); darkModeBtn.classList.add('glow-active'); }
    });

    // FPS Button Logic
    const fpsBtn = document.getElementById('fps-btn');
    fpsBtn.addEventListener('click', () => {
        showFPS = !showFPS;
        fpsBtn.classList.toggle('active');
        fpsDisplay.classList.toggle('visible');
    });

    const setupSlider=(key,isSingle)=>{const suffix=isSingle?"-s":"",slider=document.getElementById(key+suffix),numInput=document.getElementById(`${key}-input${suffix}`),display=document.getElementById(`${key}-num${suffix}`),zeroBtn=slider.parentElement.querySelector(".zero-btn"),resetBtn=slider.parentElement.querySelector(".reset-btn");function updateValue(value){const min=parseFloat(slider.min),max=parseFloat(slider.max),clampedValue=Math.max(min,Math.min(max,value));slider.value=clampedValue,numInput&&(numInput.value=clampedValue),display&&(display.textContent=clampedValue.toFixed("tamanho"===key?0:2)),isSingle?selectedBall&&(selectedBall[key]=clampedValue):settings[key]=clampedValue}slider.addEventListener("input",()=>updateValue(parseFloat(slider.value))),numInput&&numInput.addEventListener("change",()=>updateValue(parseFloat(numInput.value))),zeroBtn&&zeroBtn.addEventListener("click",()=>updateValue(0)),resetBtn&&resetBtn.addEventListener("click",()=>{isSingle?selectedBall&&(selectedBall[key]=null,updateValue(settings[key])):updateValue(defaultSettings[key])})};const sliderKeys=["tamanho","gravidade","vento","elasticidade","restitution"];sliderKeys.forEach(key=>setupSlider(key,!1)),sliderKeys.forEach(key=>setupSlider(key,!0)),document.getElementById("sound-toggle").addEventListener("change",e=>soundEnabled=e.target.checked),document.getElementById("lemon-sound-toggle").addEventListener("change",e=>useLemonSounds=e.target.checked),document.querySelector('.sounds-toggle').addEventListener('click', e => e.currentTarget.parentElement.classList.toggle('open')),document.getElementById("ultra-graphics-toggle").addEventListener("change",e=>ultraGraphicsEnabled=e.target.checked),document.getElementById("trails-toggle").addEventListener("change",e=>{trailsEnabled=e.target.checked;bolas.forEach(b=>b.trailsEnabled=null)}),document.getElementById("color-toggle").addEventListener("change",e=>{changeColorOnBounce=e.target.checked,bolas.forEach(b=>b.changeColorOnBounceEnabled=changeColorOnBounce),changeColorOnBounce&&(allRainbows=!1,bolas.forEach(b=>b.isRainbow=!1),syncUIToSettings())}),document.getElementById("rainbows-toggle").addEventListener("change",e=>{allRainbows=e.target.checked;const colorToggle=document.getElementById("color-toggle");colorToggle.disabled=allRainbows,bolas.forEach(b=>{if(b.isLemon)return;b.isRainbow=allRainbows}),allRainbows&&(changeColorOnBounce=!1,colorToggle.checked=!1,bolas.forEach(b=>{if(b.isLemon)return;b.changeColorOnBounceEnabled=!1}),syncUIToSettings())});const animationToggle=document.getElementById("animation-toggle"),squishyToggle=document.getElementById("squishy-toggle");animationToggle.addEventListener("change",e=>{animationsEnabled=e.target.checked,squishyToggle.disabled=!animationsEnabled}),squishyToggle.addEventListener("change",e=>extraSquishy=e.target.checked),document.getElementById("add-btn").addEventListener("click",createBall),document.getElementById("clear-btn").addEventListener("click",()=>{confirm("Are you sure you want to clear all balls?")&&(bolas=[],particles=[],selectedBall=null,world.innerHTML="",deletedBolasStack=[],updateUndoButtonVisibility(),updateEditorUI())}),document.getElementById("undo-btn").addEventListener("click",()=>{deletedBolasStack.length>0&&(ballToRestore=deletedBolasStack.pop(),bolas.push(ballToRestore),world.appendChild(ballToRestore.elm), ballToRestore.ghosts.forEach(g=>world.appendChild(g.elm)), updateUndoButtonVisibility())}),document.getElementById("editor-btn").addEventListener("click",()=>{document.getElementById("side-box").classList.add("hidden"),document.getElementById("editor-box").classList.remove("hidden"),document.body.classList.add("editor-active"),lastActiveMenuId="editor-box",updateUndoButtonVisibility(),updateEditorUI()}),document.getElementById("done-btn").addEventListener("click",closeEditor),document.getElementById("reset-btn").addEventListener("click",()=>{settings={...defaultSettings},trailsEnabled=!1,changeColorOnBounce=!1,animationsEnabled=!0,extraSquishy=!1,allRainbows=!1,ultraGraphicsEnabled=!1,bolas.forEach(b=>{b.isRainbow=!1,b.isLemon=!1,b.animationsEnabled=!0,b.trailsEnabled=null,b.changeColorOnBounceEnabled=!1,b.innerElm.style.backgroundColor=getRandomColor(),sliderKeys.forEach(key=>b[key]=null),b.ultraGraphicsEnabled=null}),syncUIToSettings()});
    
    // Updated Delete Button with Ghost cleanup
    document.getElementById("delete-btn").addEventListener("click",()=>{
        if(selectedBall && bolas.indexOf(selectedBall)>-1){
            world.removeChild(selectedBall.elm);
            if(selectedBall.highlightElm) world.removeChild(selectedBall.highlightElm);
            // Clean up ghosts
            selectedBall.ghosts.forEach(g => { if(g.elm.parentNode) world.removeChild(g.elm); });
            
            bolas.splice(bolas.indexOf(selectedBall),1);
            // Note: Complex to restore ghosts in undo, so we don't push to stack for simplicity in this version, 
            // or recreate them on undo. For now, simplified delete:
            // deletedBolasStack.push(selectedBall); 
            selectedBall=null;
            updateEditorUI();
            updateUndoButtonVisibility();
        }
    });
    
    const isTouchDevice=window.matchMedia("(pointer: coarse)").matches,menuToggleHint=document.getElementById("menu-toggle-hint"),showMenuHint=document.getElementById("show-menu-hint");isTouchDevice?(document.body.addEventListener("touchstart",e=>{initAudioContext(),("world"===e.target.id&&2===e.touches.length)&&(e.preventDefault(),toggleMenu())}),showMenuHint.textContent="Two-finger tap to show menu",menuToggleHint.textContent="Two-finger tap the background to hide/show."):(clickCount=0,lastClickTime=0,document.body.addEventListener("click",e=>{if(initAudioContext(),"world"!==e.target.id)return;const currentTime=(new Date).getTime();currentTime-lastClickTime>400?clickCount=1:clickCount++,lastClickTime=currentTime,3===clickCount&&(toggleMenu(),clickCount=0)}),showMenuHint.textContent="Triple-click to show menu",menuToggleHint.textContent="Triple-click the background to hide/show this menu."),document.getElementById("randomize-colors-btn").addEventListener("click",()=>{bolas.forEach(b=>{if(b.isLemon)return;applyColorToBall(getRandomColor(),b)})}),document.getElementById("randomize-color-btn-single").addEventListener("click",()=>{selectedBall&&applyColorToBall(getRandomColor(),selectedBall)}),document.getElementById("lemons-btn-global").addEventListener("click",()=>{bolas.forEach(b=>{b.isLemon=!0; b.elm.classList.add('is-lemon'); b.innerElm.style.backgroundColor="#FFFF00";b.isRainbow=!1})}),document.getElementById("lemon-btn-single").addEventListener("click",()=>{selectedBall&&(selectedBall.isLemon=!0, selectedBall.elm.classList.add('is-lemon'), selectedBall.innerElm.style.backgroundColor="#FFFF00",selectedBall.isRainbow=!1,updateEditorUI())}),document.documentElement.addEventListener("mouseup",mouseUp),document.documentElement.addEventListener("touchend",mouseUp),document.documentElement.addEventListener("mousemove",mouseMove),document.documentElement.addEventListener("touchmove",mouseMove);

    // --- Gyroscope Setup ---
    const gyroBtn = document.getElementById('gyro-btn');
    let gyroListenerAdded = false;
    const checkGyro = (e) => {
        if (e.alpha !== null || e.beta !== null || e.gamma !== null) {
            gyroBtn.classList.remove('disabled');
            gyroBtn.addEventListener('click', toggleGyro);
        }
        window.removeEventListener('deviceorientation', checkGyro);
        gyroListenerAdded = false;
    };
    if (window.DeviceOrientationEvent) { window.addEventListener('deviceorientation', checkGyro); gyroListenerAdded = true; }
    let hoverTimeout;
    gyroBtn.addEventListener('mouseenter', () => { if (gyroBtn.classList.contains('disabled')) { hoverTimeout = setTimeout(() => { gyroBtn.title = "Your device doesn't support gyroscope controls."; }, 1000); } });
    gyroBtn.addEventListener('mouseleave', () => { clearTimeout(hoverTimeout); gyroBtn.title = ""; });

    syncUIToSettings(),setupEditor();updateFullscreenIcon();for(let i=0;i<3;i++)createBall();gameLoop()
}

init();

// --- KEYBOARD SHORTCUTS ---
document.addEventListener("keydown", (e) => {
  if (e.target.tagName === "INPUT" || e.target.tagName === "TEXTAREA") return;
  if (e.key.toLowerCase() === "a") { createBall(); }
});
</script>
</body>
</html>